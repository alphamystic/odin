// Code generated by protoc-gen-go. DO NOT EDIT.
// source: wheagle.proto

package grpcapi

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Event struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	ID                   string   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	EType                int32    `protobuf:"varint,3,opt,name=EType,proto3" json:"EType,omitempty"`
	Handled              bool     `protobuf:"varint,4,opt,name=Handled,proto3" json:"Handled,omitempty"`
	CreatedAt            string   `protobuf:"bytes,5,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	UpdatedAt            string   `protobuf:"bytes,6,opt,name=UpdatedAt,proto3" json:"UpdatedAt,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{0}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Event) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Event) GetEType() int32 {
	if m != nil {
		return m.EType
	}
	return 0
}

func (m *Event) GetHandled() bool {
	if m != nil {
		return m.Handled
	}
	return false
}

func (m *Event) GetCreatedAt() string {
	if m != nil {
		return m.CreatedAt
	}
	return ""
}

func (m *Event) GetUpdatedAt() string {
	if m != nil {
		return m.UpdatedAt
	}
	return ""
}

type Events struct {
	C2Events             []*Event `protobuf:"bytes,1,rep,name=C2Events,proto3" json:"C2Events,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Events) Reset()         { *m = Events{} }
func (m *Events) String() string { return proto.CompactTextString(m) }
func (*Events) ProtoMessage()    {}
func (*Events) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{1}
}

func (m *Events) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Events.Unmarshal(m, b)
}
func (m *Events) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Events.Marshal(b, m, deterministic)
}
func (m *Events) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Events.Merge(m, src)
}
func (m *Events) XXX_Size() int {
	return xxx_messageInfo_Events.Size(m)
}
func (m *Events) XXX_DiscardUnknown() {
	xxx_messageInfo_Events.DiscardUnknown(m)
}

var xxx_messageInfo_Events proto.InternalMessageInfo

func (m *Events) GetC2Events() []*Event {
	if m != nil {
		return m.C2Events
	}
	return nil
}

// Command defines a with both input and output fields
type Command struct {
	In                   string   `protobuf:"bytes,1,opt,name=In,proto3" json:"In,omitempty"`
	Out                  string   `protobuf:"bytes,2,opt,name=Out,proto3" json:"Out,omitempty"`
	Individual           bool     `protobuf:"varint,3,opt,name=Individual,proto3" json:"Individual,omitempty"`
	UserId               string   `protobuf:"bytes,4,opt,name=UserId,proto3" json:"UserId,omitempty"`
	OperatorId           string   `protobuf:"bytes,5,opt,name=OperatorId,proto3" json:"OperatorId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{2}
}

func (m *Command) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command.Unmarshal(m, b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command.Marshal(b, m, deterministic)
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return xxx_messageInfo_Command.Size(m)
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *Command) GetOut() string {
	if m != nil {
		return m.Out
	}
	return ""
}

func (m *Command) GetIndividual() bool {
	if m != nil {
		return m.Individual
	}
	return false
}

func (m *Command) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Command) GetOperatorId() string {
	if m != nil {
		return m.OperatorId
	}
	return ""
}

type C2Command struct {
	In                   string   `protobuf:"bytes,1,opt,name=In,proto3" json:"In,omitempty"`
	Out                  string   `protobuf:"bytes,2,opt,name=Out,proto3" json:"Out,omitempty"`
	Individual           bool     `protobuf:"varint,3,opt,name=Individual,proto3" json:"Individual,omitempty"`
	MSId                 string   `protobuf:"bytes,4,opt,name=MSId,proto3" json:"MSId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *C2Command) Reset()         { *m = C2Command{} }
func (m *C2Command) String() string { return proto.CompactTextString(m) }
func (*C2Command) ProtoMessage()    {}
func (*C2Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{3}
}

func (m *C2Command) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_C2Command.Unmarshal(m, b)
}
func (m *C2Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_C2Command.Marshal(b, m, deterministic)
}
func (m *C2Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_C2Command.Merge(m, src)
}
func (m *C2Command) XXX_Size() int {
	return xxx_messageInfo_C2Command.Size(m)
}
func (m *C2Command) XXX_DiscardUnknown() {
	xxx_messageInfo_C2Command.DiscardUnknown(m)
}

var xxx_messageInfo_C2Command proto.InternalMessageInfo

func (m *C2Command) GetIn() string {
	if m != nil {
		return m.In
	}
	return ""
}

func (m *C2Command) GetOut() string {
	if m != nil {
		return m.Out
	}
	return ""
}

func (m *C2Command) GetIndividual() bool {
	if m != nil {
		return m.Individual
	}
	return false
}

func (m *C2Command) GetMSId() string {
	if m != nil {
		return m.MSId
	}
	return ""
}

// Empty defines an empty message used in place of null
type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{4}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type Screenshots struct {
	UserId               string   `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Screenshot           []string `protobuf:"bytes,2,rep,name=Screenshot,proto3" json:"Screenshot,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Screenshots) Reset()         { *m = Screenshots{} }
func (m *Screenshots) String() string { return proto.CompactTextString(m) }
func (*Screenshots) ProtoMessage()    {}
func (*Screenshots) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{5}
}

func (m *Screenshots) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Screenshots.Unmarshal(m, b)
}
func (m *Screenshots) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Screenshots.Marshal(b, m, deterministic)
}
func (m *Screenshots) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Screenshots.Merge(m, src)
}
func (m *Screenshots) XXX_Size() int {
	return xxx_messageInfo_Screenshots.Size(m)
}
func (m *Screenshots) XXX_DiscardUnknown() {
	xxx_messageInfo_Screenshots.DiscardUnknown(m)
}

var xxx_messageInfo_Screenshots proto.InternalMessageInfo

func (m *Screenshots) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Screenshots) GetScreenshot() []string {
	if m != nil {
		return m.Screenshot
	}
	return nil
}

type Encoded struct {
	Data                 string   `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Encoded) Reset()         { *m = Encoded{} }
func (m *Encoded) String() string { return proto.CompactTextString(m) }
func (*Encoded) ProtoMessage()    {}
func (*Encoded) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{6}
}

func (m *Encoded) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Encoded.Unmarshal(m, b)
}
func (m *Encoded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Encoded.Marshal(b, m, deterministic)
}
func (m *Encoded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Encoded.Merge(m, src)
}
func (m *Encoded) XXX_Size() int {
	return xxx_messageInfo_Encoded.Size(m)
}
func (m *Encoded) XXX_DiscardUnknown() {
	xxx_messageInfo_Encoded.DiscardUnknown(m)
}

var xxx_messageInfo_Encoded proto.InternalMessageInfo

func (m *Encoded) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type FileMessage struct {
	UserId               string   `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Directory            string   `protobuf:"bytes,3,opt,name=Directory,proto3" json:"Directory,omitempty"`
	Done                 bool     `protobuf:"varint,4,opt,name=Done,proto3" json:"Done,omitempty"`
	Pid                  int32    `protobuf:"varint,5,opt,name=Pid,proto3" json:"Pid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileMessage) Reset()         { *m = FileMessage{} }
func (m *FileMessage) String() string { return proto.CompactTextString(m) }
func (*FileMessage) ProtoMessage()    {}
func (*FileMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{7}
}

func (m *FileMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileMessage.Unmarshal(m, b)
}
func (m *FileMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileMessage.Marshal(b, m, deterministic)
}
func (m *FileMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileMessage.Merge(m, src)
}
func (m *FileMessage) XXX_Size() int {
	return xxx_messageInfo_FileMessage.Size(m)
}
func (m *FileMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FileMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FileMessage proto.InternalMessageInfo

func (m *FileMessage) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *FileMessage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileMessage) GetDirectory() string {
	if m != nil {
		return m.Directory
	}
	return ""
}

func (m *FileMessage) GetDone() bool {
	if m != nil {
		return m.Done
	}
	return false
}

func (m *FileMessage) GetPid() int32 {
	if m != nil {
		return m.Pid
	}
	return 0
}

type File struct {
	UserId               string   `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Run                  bool     `protobuf:"varint,4,opt,name=Run,proto3" json:"Run,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{8}
}

func (m *File) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_File.Unmarshal(m, b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_File.Marshal(b, m, deterministic)
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return xxx_messageInfo_File.Size(m)
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *File) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *File) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *File) GetRun() bool {
	if m != nil {
		return m.Run
	}
	return false
}

type Loot struct {
	Files                []*File  `protobuf:"bytes,1,rep,name=Files,proto3" json:"Files,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Loot) Reset()         { *m = Loot{} }
func (m *Loot) String() string { return proto.CompactTextString(m) }
func (*Loot) ProtoMessage()    {}
func (*Loot) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{9}
}

func (m *Loot) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Loot.Unmarshal(m, b)
}
func (m *Loot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Loot.Marshal(b, m, deterministic)
}
func (m *Loot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Loot.Merge(m, src)
}
func (m *Loot) XXX_Size() int {
	return xxx_messageInfo_Loot.Size(m)
}
func (m *Loot) XXX_DiscardUnknown() {
	xxx_messageInfo_Loot.DiscardUnknown(m)
}

var xxx_messageInfo_Loot proto.InternalMessageInfo

func (m *Loot) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

type Auth struct {
	UserId               string   `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Authenticated        bool     `protobuf:"varint,2,opt,name=Authenticated,proto3" json:"Authenticated,omitempty"`
	MSId                 string   `protobuf:"bytes,3,opt,name=MSId,proto3" json:"MSId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Auth) Reset()         { *m = Auth{} }
func (m *Auth) String() string { return proto.CompactTextString(m) }
func (*Auth) ProtoMessage()    {}
func (*Auth) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{10}
}

func (m *Auth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Auth.Unmarshal(m, b)
}
func (m *Auth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Auth.Marshal(b, m, deterministic)
}
func (m *Auth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Auth.Merge(m, src)
}
func (m *Auth) XXX_Size() int {
	return xxx_messageInfo_Auth.Size(m)
}
func (m *Auth) XXX_DiscardUnknown() {
	xxx_messageInfo_Auth.DiscardUnknown(m)
}

var xxx_messageInfo_Auth proto.InternalMessageInfo

func (m *Auth) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *Auth) GetAuthenticated() bool {
	if m != nil {
		return m.Authenticated
	}
	return false
}

func (m *Auth) GetMSId() string {
	if m != nil {
		return m.MSId
	}
	return ""
}

type ReverseShellRequest struct {
	Input                []byte   `protobuf:"bytes,1,opt,name=Input,proto3" json:"Input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReverseShellRequest) Reset()         { *m = ReverseShellRequest{} }
func (m *ReverseShellRequest) String() string { return proto.CompactTextString(m) }
func (*ReverseShellRequest) ProtoMessage()    {}
func (*ReverseShellRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{11}
}

func (m *ReverseShellRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReverseShellRequest.Unmarshal(m, b)
}
func (m *ReverseShellRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReverseShellRequest.Marshal(b, m, deterministic)
}
func (m *ReverseShellRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseShellRequest.Merge(m, src)
}
func (m *ReverseShellRequest) XXX_Size() int {
	return xxx_messageInfo_ReverseShellRequest.Size(m)
}
func (m *ReverseShellRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseShellRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseShellRequest proto.InternalMessageInfo

func (m *ReverseShellRequest) GetInput() []byte {
	if m != nil {
		return m.Input
	}
	return nil
}

type ReverseShellResponse struct {
	Output               []byte   `protobuf:"bytes,1,opt,name=Output,proto3" json:"Output,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReverseShellResponse) Reset()         { *m = ReverseShellResponse{} }
func (m *ReverseShellResponse) String() string { return proto.CompactTextString(m) }
func (*ReverseShellResponse) ProtoMessage()    {}
func (*ReverseShellResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{12}
}

func (m *ReverseShellResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReverseShellResponse.Unmarshal(m, b)
}
func (m *ReverseShellResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReverseShellResponse.Marshal(b, m, deterministic)
}
func (m *ReverseShellResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReverseShellResponse.Merge(m, src)
}
func (m *ReverseShellResponse) XXX_Size() int {
	return xxx_messageInfo_ReverseShellResponse.Size(m)
}
func (m *ReverseShellResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReverseShellResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReverseShellResponse proto.InternalMessageInfo

func (m *ReverseShellResponse) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

type Minion struct {
	MinionId             string   `protobuf:"bytes,1,opt,name=MinionId,proto3" json:"MinionId,omitempty"`
	MSession             string   `protobuf:"bytes,2,opt,name=MSession,proto3" json:"MSession,omitempty"`
	HostName             string   `protobuf:"bytes,3,opt,name=HostName,proto3" json:"HostName,omitempty"`
	Username             string   `protobuf:"bytes,4,opt,name=Username,proto3" json:"Username,omitempty"`
	Userid               string   `protobuf:"bytes,5,opt,name=Userid,proto3" json:"Userid,omitempty"`
	GroupId              string   `protobuf:"bytes,6,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	Homedir              string   `protobuf:"bytes,7,opt,name=Homedir,proto3" json:"Homedir,omitempty"`
	MinionType           string   `protobuf:"bytes,8,opt,name=MinionType,proto3" json:"MinionType,omitempty"`
	OsType               string   `protobuf:"bytes,9,opt,name=OsType,proto3" json:"OsType,omitempty"`
	Description          string   `protobuf:"bytes,10,opt,name=Description,proto3" json:"Description,omitempty"`
	Installed            bool     `protobuf:"varint,11,opt,name=Installed,proto3" json:"Installed,omitempty"`
	MothershipId         string   `protobuf:"bytes,12,opt,name=MothershipId,proto3" json:"MothershipId,omitempty"`
	MinionIp             string   `protobuf:"bytes,13,opt,name=MinionIp,proto3" json:"MinionIp,omitempty"`
	OwnerId              string   `protobuf:"bytes,14,opt,name=OwnerId,proto3" json:"OwnerId,omitempty"`
	Lastseen             string   `protobuf:"bytes,15,opt,name=Lastseen,proto3" json:"Lastseen,omitempty"`
	PID                  string   `protobuf:"bytes,16,opt,name=PID,proto3" json:"PID,omitempty"`
	Persistance          bool     `protobuf:"varint,17,opt,name=Persistance,proto3" json:"Persistance,omitempty"`
	PersistanceMode      string   `protobuf:"bytes,18,opt,name=PersistanceMode,proto3" json:"PersistanceMode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Minion) Reset()         { *m = Minion{} }
func (m *Minion) String() string { return proto.CompactTextString(m) }
func (*Minion) ProtoMessage()    {}
func (*Minion) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c1e9e82a03cb1da, []int{13}
}

func (m *Minion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Minion.Unmarshal(m, b)
}
func (m *Minion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Minion.Marshal(b, m, deterministic)
}
func (m *Minion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Minion.Merge(m, src)
}
func (m *Minion) XXX_Size() int {
	return xxx_messageInfo_Minion.Size(m)
}
func (m *Minion) XXX_DiscardUnknown() {
	xxx_messageInfo_Minion.DiscardUnknown(m)
}

var xxx_messageInfo_Minion proto.InternalMessageInfo

func (m *Minion) GetMinionId() string {
	if m != nil {
		return m.MinionId
	}
	return ""
}

func (m *Minion) GetMSession() string {
	if m != nil {
		return m.MSession
	}
	return ""
}

func (m *Minion) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *Minion) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Minion) GetUserid() string {
	if m != nil {
		return m.Userid
	}
	return ""
}

func (m *Minion) GetGroupId() string {
	if m != nil {
		return m.GroupId
	}
	return ""
}

func (m *Minion) GetHomedir() string {
	if m != nil {
		return m.Homedir
	}
	return ""
}

func (m *Minion) GetMinionType() string {
	if m != nil {
		return m.MinionType
	}
	return ""
}

func (m *Minion) GetOsType() string {
	if m != nil {
		return m.OsType
	}
	return ""
}

func (m *Minion) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Minion) GetInstalled() bool {
	if m != nil {
		return m.Installed
	}
	return false
}

func (m *Minion) GetMothershipId() string {
	if m != nil {
		return m.MothershipId
	}
	return ""
}

func (m *Minion) GetMinionIp() string {
	if m != nil {
		return m.MinionIp
	}
	return ""
}

func (m *Minion) GetOwnerId() string {
	if m != nil {
		return m.OwnerId
	}
	return ""
}

func (m *Minion) GetLastseen() string {
	if m != nil {
		return m.Lastseen
	}
	return ""
}

func (m *Minion) GetPID() string {
	if m != nil {
		return m.PID
	}
	return ""
}

func (m *Minion) GetPersistance() bool {
	if m != nil {
		return m.Persistance
	}
	return false
}

func (m *Minion) GetPersistanceMode() string {
	if m != nil {
		return m.PersistanceMode
	}
	return ""
}

func init() {
	proto.RegisterType((*Event)(nil), "grpcapi.Event")
	proto.RegisterType((*Events)(nil), "grpcapi.Events")
	proto.RegisterType((*Command)(nil), "grpcapi.Command")
	proto.RegisterType((*C2Command)(nil), "grpcapi.C2Command")
	proto.RegisterType((*Empty)(nil), "grpcapi.Empty")
	proto.RegisterType((*Screenshots)(nil), "grpcapi.Screenshots")
	proto.RegisterType((*Encoded)(nil), "grpcapi.Encoded")
	proto.RegisterType((*FileMessage)(nil), "grpcapi.FileMessage")
	proto.RegisterType((*File)(nil), "grpcapi.File")
	proto.RegisterType((*Loot)(nil), "grpcapi.Loot")
	proto.RegisterType((*Auth)(nil), "grpcapi.Auth")
	proto.RegisterType((*ReverseShellRequest)(nil), "grpcapi.ReverseShellRequest")
	proto.RegisterType((*ReverseShellResponse)(nil), "grpcapi.ReverseShellResponse")
	proto.RegisterType((*Minion)(nil), "grpcapi.Minion")
}

func init() {
	proto.RegisterFile("wheagle.proto", fileDescriptor_7c1e9e82a03cb1da)
}

var fileDescriptor_7c1e9e82a03cb1da = []byte{
	// 955 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x86, 0xfe, 0xa5, 0x91, 0x64, 0xcb, 0x1b, 0xa3, 0x60, 0x8d, 0xb4, 0x10, 0xd8, 0x1e, 0x84,
	0x06, 0x15, 0x12, 0x35, 0x48, 0xd3, 0x53, 0x61, 0x58, 0x4a, 0x43, 0x20, 0xaa, 0x8d, 0x55, 0x0c,
	0xf4, 0xca, 0x8a, 0x03, 0x8b, 0x28, 0xb5, 0xcb, 0x72, 0x97, 0x36, 0x7c, 0xe8, 0xa5, 0x7d, 0x81,
	0xde, 0xfa, 0xa0, 0x7d, 0x81, 0x62, 0x76, 0xf9, 0x27, 0x59, 0x29, 0x62, 0x20, 0xb7, 0x99, 0x6f,
	0x76, 0x38, 0xdf, 0x37, 0x3b, 0x3b, 0x12, 0x0c, 0xef, 0x36, 0xe8, 0xdf, 0x44, 0x38, 0x8d, 0x13,
	0xa9, 0x25, 0xeb, 0xdc, 0x24, 0xf1, 0xda, 0x8f, 0x43, 0xf7, 0x9f, 0x1a, 0xb4, 0x16, 0xb7, 0x28,
	0x34, 0x63, 0xd0, 0xfc, 0xd9, 0xdf, 0xa2, 0x53, 0x1b, 0xd7, 0x26, 0x3d, 0x6e, 0x6c, 0x76, 0x04,
	0x75, 0x6f, 0xee, 0xd4, 0x0d, 0x52, 0xf7, 0xe6, 0xec, 0x14, 0x5a, 0x8b, 0xf7, 0xf7, 0x31, 0x3a,
	0x8d, 0x71, 0x6d, 0xd2, 0xe2, 0xd6, 0x61, 0x0e, 0x74, 0xde, 0xfa, 0x22, 0x88, 0x30, 0x70, 0x9a,
	0xe3, 0xda, 0xa4, 0xcb, 0x73, 0x97, 0x3d, 0x85, 0xde, 0x45, 0x82, 0xbe, 0xc6, 0xe0, 0x5c, 0x3b,
	0x2d, 0xf3, 0x99, 0x12, 0xa0, 0xe8, 0x75, 0x1c, 0x64, 0xd1, 0xb6, 0x8d, 0x16, 0x80, 0xfb, 0x12,
	0xda, 0x86, 0x98, 0x62, 0xdf, 0x40, 0xf7, 0x62, 0x66, 0x6d, 0xa7, 0x36, 0x6e, 0x4c, 0xfa, 0xb3,
	0xa3, 0x69, 0xc6, 0x7f, 0x6a, 0x60, 0x5e, 0xc4, 0xdd, 0xbf, 0x6a, 0xd0, 0xb9, 0x90, 0xdb, 0xad,
	0x2f, 0x02, 0xc3, 0x5e, 0x64, 0x7a, 0xea, 0x9e, 0x60, 0x23, 0x68, 0x5c, 0xa6, 0x3a, 0x93, 0x43,
	0x26, 0xfb, 0x12, 0xc0, 0x13, 0x41, 0x78, 0x1b, 0x06, 0xa9, 0x1f, 0x19, 0x51, 0x5d, 0x5e, 0x41,
	0xd8, 0x67, 0xd0, 0xbe, 0x56, 0x98, 0x78, 0x56, 0x58, 0x8f, 0x67, 0x1e, 0xe5, 0x5d, 0xc6, 0x98,
	0xf8, 0x5a, 0x52, 0xcc, 0x0a, 0xab, 0x20, 0xae, 0x0f, 0xbd, 0x8b, 0xd9, 0xa7, 0xa3, 0xc1, 0xa0,
	0xb9, 0x5c, 0x15, 0x24, 0x8c, 0xed, 0x76, 0xa0, 0xb5, 0xd8, 0xc6, 0xfa, 0xde, 0x5d, 0x40, 0x7f,
	0xb5, 0x4e, 0x10, 0x85, 0xda, 0x48, 0xad, 0x2a, 0x94, 0x6b, 0xfb, 0x94, 0xcb, 0x63, 0x4e, 0x7d,
	0xdc, 0x20, 0xca, 0x25, 0xe2, 0x7e, 0x01, 0x9d, 0x85, 0x58, 0xcb, 0x00, 0x03, 0x2a, 0x37, 0xf7,
	0xb5, 0x9f, 0x4f, 0x02, 0xd9, 0xee, 0x1f, 0xd0, 0x7f, 0x13, 0x46, 0xb8, 0x44, 0xa5, 0xfc, 0x1b,
	0xfc, 0x60, 0x95, 0x7c, 0x88, 0xea, 0x95, 0x21, 0x7a, 0x0a, 0xbd, 0x79, 0x98, 0xe0, 0x5a, 0xcb,
	0xe4, 0xde, 0x88, 0xeb, 0xf1, 0x12, 0x30, 0xc5, 0xa4, 0xc0, 0x6c, 0x72, 0x8c, 0x4d, 0x1d, 0xba,
	0x0a, 0x6d, 0x5f, 0x5b, 0x9c, 0x4c, 0xf7, 0x17, 0x68, 0x52, 0xf9, 0xff, 0xab, 0x6b, 0x28, 0x53,
	0xdd, 0x81, 0xa5, 0x5c, 0x70, 0x69, 0x54, 0xb8, 0x8c, 0xa0, 0xc1, 0x53, 0x91, 0x15, 0x23, 0xd3,
	0x7d, 0x06, 0xcd, 0x77, 0x52, 0x6a, 0xf6, 0x15, 0xb4, 0xa8, 0x42, 0x3e, 0x61, 0xc3, 0x62, 0xc2,
	0x08, 0xe5, 0x36, 0x46, 0x34, 0xce, 0x53, 0xbd, 0xf9, 0x20, 0x8d, 0xaf, 0x61, 0x48, 0x71, 0x14,
	0x3a, 0x5c, 0xd3, 0x18, 0x1b, 0x3e, 0x5d, 0xbe, 0x0b, 0x16, 0xd7, 0xd9, 0xa8, 0x5c, 0xe7, 0x33,
	0x78, 0xc2, 0xf1, 0x16, 0x13, 0x85, 0xab, 0x0d, 0x46, 0x11, 0xc7, 0xdf, 0x53, 0x54, 0x9a, 0x1e,
	0x9c, 0x27, 0xe2, 0x54, 0x9b, 0x3a, 0x03, 0x6e, 0x1d, 0x77, 0x0a, 0xa7, 0xbb, 0x87, 0x55, 0x2c,
	0x85, 0x32, 0xdd, 0xb9, 0x4c, 0x75, 0x79, 0x3c, 0xf3, 0xdc, 0xbf, 0x9b, 0xd0, 0x5e, 0x86, 0x22,
	0x94, 0x82, 0x9d, 0x41, 0xd7, 0x5a, 0x05, 0xf7, 0xc2, 0x37, 0xb1, 0x15, 0x2a, 0x15, 0x4a, 0x91,
	0x5d, 0x60, 0xe1, 0x53, 0xec, 0xad, 0x54, 0xba, 0xd2, 0xd0, 0xc2, 0xa7, 0x18, 0xe9, 0x17, 0x14,
	0xb3, 0x23, 0x5a, 0xf8, 0x79, 0xa7, 0xc2, 0xfc, 0x95, 0x64, 0x1e, 0xed, 0x8c, 0x9f, 0x12, 0x99,
	0xc6, 0x5e, 0x90, 0xbd, 0xfc, 0xdc, 0x35, 0xdb, 0x44, 0x6e, 0x31, 0x08, 0x13, 0xa7, 0x63, 0x23,
	0x99, 0x4b, 0x23, 0x6c, 0xb9, 0x9a, 0x15, 0xd4, 0xb5, 0xaf, 0xae, 0x44, 0x8c, 0x7c, 0x65, 0x62,
	0x3d, 0x5b, 0xcb, 0x7a, 0x6c, 0x0c, 0xfd, 0x39, 0xaa, 0x75, 0x12, 0xc6, 0x9a, 0xa4, 0x81, 0x09,
	0x56, 0x21, 0x1a, 0x51, 0x4f, 0x28, 0xed, 0x47, 0xb4, 0xc3, 0xfa, 0xe6, 0xce, 0x4a, 0x80, 0xb9,
	0x30, 0x58, 0x4a, 0xbd, 0xc1, 0x44, 0x6d, 0x42, 0x22, 0x3c, 0x30, 0x1f, 0xd8, 0xc1, 0x2a, 0x7d,
	0x8d, 0x9d, 0xe1, 0x4e, 0x5f, 0x63, 0x52, 0x74, 0x79, 0x27, 0xcc, 0xb8, 0x1c, 0x59, 0x45, 0x99,
	0x4b, 0x59, 0xef, 0x7c, 0xa5, 0x15, 0xa2, 0x70, 0x8e, 0x6d, 0x56, 0xee, 0x9b, 0x47, 0xe0, 0xcd,
	0x9d, 0x91, 0x5d, 0x13, 0x57, 0xde, 0x9c, 0x74, 0x5c, 0x61, 0xa2, 0x42, 0xa5, 0x7d, 0xb1, 0x46,
	0xe7, 0xc4, 0xf0, 0xac, 0x42, 0x6c, 0x02, 0xc7, 0x15, 0x77, 0x29, 0x03, 0x74, 0x98, 0xc9, 0xdf,
	0x87, 0x67, 0xff, 0xd6, 0xa1, 0xe3, 0x6d, 0xe3, 0xc8, 0x17, 0x9a, 0xcd, 0x60, 0xf0, 0x06, 0xf5,
	0x7a, 0x93, 0x2f, 0xac, 0x51, 0x31, 0xfb, 0x19, 0x72, 0xf6, 0x00, 0x61, 0x53, 0x80, 0x15, 0x8a,
	0xc0, 0x0e, 0xd8, 0x81, 0x8c, 0xca, 0x86, 0xa6, 0x2d, 0xc5, 0x5e, 0xc0, 0x09, 0x4f, 0x45, 0xe5,
	0x1d, 0x50, 0xdb, 0xcb, 0x47, 0x46, 0x81, 0xb3, 0x5d, 0x97, 0x3d, 0x87, 0x21, 0xc7, 0x35, 0x86,
	0xb7, 0x78, 0x1d, 0x47, 0xd2, 0x3f, 0xc4, 0x6b, 0xf7, 0x95, 0xb2, 0xd7, 0x30, 0x22, 0x52, 0xf6,
	0x38, 0xc7, 0x58, 0x26, 0x9a, 0x9d, 0xee, 0x1c, 0xc9, 0xf6, 0xd7, 0x03, 0x7a, 0xdf, 0xc2, 0x80,
	0x32, 0xe7, 0xf2, 0x4e, 0x98, 0x52, 0xbb, 0x1f, 0x7e, 0x70, 0xfc, 0x15, 0x1c, 0xbd, 0xf7, 0x7f,
	0x43, 0xbb, 0x3e, 0x57, 0x1b, 0x59, 0x2d, 0x53, 0x59, 0xc6, 0xfb, 0x79, 0xb3, 0x3f, 0x9b, 0xd0,
	0x3a, 0x0f, 0xb6, 0xa1, 0x60, 0xcf, 0x01, 0x78, 0x2a, 0x1e, 0xd3, 0xf1, 0xd7, 0x70, 0x62, 0x52,
	0x73, 0x8e, 0x46, 0xf1, 0x61, 0x75, 0x7b, 0x6d, 0x79, 0x09, 0x43, 0x93, 0x49, 0x0a, 0x0d, 0xb0,
	0xa7, 0xee, 0xe0, 0x47, 0xd8, 0xf7, 0x30, 0xa4, 0x1b, 0x2b, 0x7f, 0xc7, 0x58, 0x49, 0x29, 0xc7,
	0xce, 0x0e, 0x60, 0xec, 0x07, 0xf8, 0x9c, 0xa7, 0x22, 0xff, 0x35, 0x7c, 0xd4, 0x95, 0xff, 0x08,
	0x4f, 0xa8, 0xaf, 0x96, 0x6d, 0xd9, 0xdc, 0x43, 0x95, 0x0f, 0x36, 0x9c, 0xbd, 0xb0, 0x63, 0x99,
	0x0d, 0xcc, 0x47, 0xe9, 0x7c, 0x05, 0xc7, 0xd9, 0x98, 0x15, 0xb7, 0xff, 0x51, 0x5d, 0xb5, 0xfd,
	0xa9, 0xb0, 0x7c, 0x78, 0x89, 0x07, 0x39, 0xfe, 0xda, 0x36, 0x7f, 0xc1, 0xbe, 0xfb, 0x2f, 0x00,
	0x00, 0xff, 0xff, 0xfa, 0x4f, 0xa9, 0xeb, 0x93, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ImplantClient is the client API for Implant service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImplantClient interface {
	FetchCommand(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Command, error)
	SendOutput(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Empty, error)
	RunAuthentication(ctx context.Context, in *Auth, opts ...grpc.CallOption) (*Auth, error)
	ReceiveUpload(ctx context.Context, in *Command, opts ...grpc.CallOption) (*File, error)
	SendUploadReport(ctx context.Context, in *FileMessage, opts ...grpc.CallOption) (*Empty, error)
	SendDownload(ctx context.Context, in *File, opts ...grpc.CallOption) (*Empty, error)
	TakeScreenShot(ctx context.Context, in *Screenshots, opts ...grpc.CallOption) (*Empty, error)
}

type implantClient struct {
	cc grpc.ClientConnInterface
}

func NewImplantClient(cc grpc.ClientConnInterface) ImplantClient {
	return &implantClient{cc}
}

func (c *implantClient) FetchCommand(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Command, error) {
	out := new(Command)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/FetchCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantClient) SendOutput(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/SendOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantClient) RunAuthentication(ctx context.Context, in *Auth, opts ...grpc.CallOption) (*Auth, error) {
	out := new(Auth)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/RunAuthentication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantClient) ReceiveUpload(ctx context.Context, in *Command, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/ReceiveUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantClient) SendUploadReport(ctx context.Context, in *FileMessage, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/SendUploadReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantClient) SendDownload(ctx context.Context, in *File, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/SendDownload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *implantClient) TakeScreenShot(ctx context.Context, in *Screenshots, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/grpcapi.Implant/TakeScreenShot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImplantServer is the server API for Implant service.
type ImplantServer interface {
	FetchCommand(context.Context, *Command) (*Command, error)
	SendOutput(context.Context, *Command) (*Empty, error)
	RunAuthentication(context.Context, *Auth) (*Auth, error)
	ReceiveUpload(context.Context, *Command) (*File, error)
	SendUploadReport(context.Context, *FileMessage) (*Empty, error)
	SendDownload(context.Context, *File) (*Empty, error)
	TakeScreenShot(context.Context, *Screenshots) (*Empty, error)
}

// UnimplementedImplantServer can be embedded to have forward compatible implementations.
type UnimplementedImplantServer struct {
}

func (*UnimplementedImplantServer) FetchCommand(ctx context.Context, req *Command) (*Command, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchCommand not implemented")
}
func (*UnimplementedImplantServer) SendOutput(ctx context.Context, req *Command) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendOutput not implemented")
}
func (*UnimplementedImplantServer) RunAuthentication(ctx context.Context, req *Auth) (*Auth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunAuthentication not implemented")
}
func (*UnimplementedImplantServer) ReceiveUpload(ctx context.Context, req *Command) (*File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveUpload not implemented")
}
func (*UnimplementedImplantServer) SendUploadReport(ctx context.Context, req *FileMessage) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendUploadReport not implemented")
}
func (*UnimplementedImplantServer) SendDownload(ctx context.Context, req *File) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDownload not implemented")
}
func (*UnimplementedImplantServer) TakeScreenShot(ctx context.Context, req *Screenshots) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeScreenShot not implemented")
}

func RegisterImplantServer(s *grpc.Server, srv ImplantServer) {
	s.RegisterService(&_Implant_serviceDesc, srv)
}

func _Implant_FetchCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).FetchCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/FetchCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).FetchCommand(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _Implant_SendOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).SendOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/SendOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).SendOutput(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _Implant_RunAuthentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Auth)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).RunAuthentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/RunAuthentication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).RunAuthentication(ctx, req.(*Auth))
	}
	return interceptor(ctx, in, info, handler)
}

func _Implant_ReceiveUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).ReceiveUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/ReceiveUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).ReceiveUpload(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _Implant_SendUploadReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).SendUploadReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/SendUploadReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).SendUploadReport(ctx, req.(*FileMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Implant_SendDownload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(File)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).SendDownload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/SendDownload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).SendDownload(ctx, req.(*File))
	}
	return interceptor(ctx, in, info, handler)
}

func _Implant_TakeScreenShot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Screenshots)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImplantServer).TakeScreenShot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Implant/TakeScreenShot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImplantServer).TakeScreenShot(ctx, req.(*Screenshots))
	}
	return interceptor(ctx, in, info, handler)
}

var _Implant_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpcapi.Implant",
	HandlerType: (*ImplantServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchCommand",
			Handler:    _Implant_FetchCommand_Handler,
		},
		{
			MethodName: "SendOutput",
			Handler:    _Implant_SendOutput_Handler,
		},
		{
			MethodName: "RunAuthentication",
			Handler:    _Implant_RunAuthentication_Handler,
		},
		{
			MethodName: "ReceiveUpload",
			Handler:    _Implant_ReceiveUpload_Handler,
		},
		{
			MethodName: "SendUploadReport",
			Handler:    _Implant_SendUploadReport_Handler,
		},
		{
			MethodName: "SendDownload",
			Handler:    _Implant_SendDownload_Handler,
		},
		{
			MethodName: "TakeScreenShot",
			Handler:    _Implant_TakeScreenShot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "wheagle.proto",
}

// AdminClient is the client API for Admin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AdminClient interface {
	RunCommand(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Command, error)
	// rpc RunMinion (Command) returns (Minion);
	AdminDownloadFile(ctx context.Context, in *FileMessage, opts ...grpc.CallOption) (*File, error)
	AdminSendFile(ctx context.Context, in *File, opts ...grpc.CallOption) (*FileMessage, error)
	// rpc AdminSendOutput (Command) returns (Command);
	RunAC2Command(ctx context.Context, in *C2Command, opts ...grpc.CallOption) (*C2Command, error)
	RunOperatorAuthentication(ctx context.Context, in *Auth, opts ...grpc.CallOption) (*Auth, error)
	TakeAdminScreenShot(ctx context.Context, in *C2Command, opts ...grpc.CallOption) (*Screenshots, error)
	SendUpload(ctx context.Context, in *File, opts ...grpc.CallOption) (*FileMessage, error)
	ReceiveDownload(ctx context.Context, in *FileMessage, opts ...grpc.CallOption) (*File, error)
	RunScreenShot(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Screenshots, error)
}

type adminClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminClient(cc grpc.ClientConnInterface) AdminClient {
	return &adminClient{cc}
}

func (c *adminClient) RunCommand(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Command, error) {
	out := new(Command)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/RunCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) AdminDownloadFile(ctx context.Context, in *FileMessage, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/AdminDownloadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) AdminSendFile(ctx context.Context, in *File, opts ...grpc.CallOption) (*FileMessage, error) {
	out := new(FileMessage)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/AdminSendFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RunAC2Command(ctx context.Context, in *C2Command, opts ...grpc.CallOption) (*C2Command, error) {
	out := new(C2Command)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/RunAC2Command", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RunOperatorAuthentication(ctx context.Context, in *Auth, opts ...grpc.CallOption) (*Auth, error) {
	out := new(Auth)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/RunOperatorAuthentication", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) TakeAdminScreenShot(ctx context.Context, in *C2Command, opts ...grpc.CallOption) (*Screenshots, error) {
	out := new(Screenshots)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/TakeAdminScreenShot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) SendUpload(ctx context.Context, in *File, opts ...grpc.CallOption) (*FileMessage, error) {
	out := new(FileMessage)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/SendUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) ReceiveDownload(ctx context.Context, in *FileMessage, opts ...grpc.CallOption) (*File, error) {
	out := new(File)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/ReceiveDownload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminClient) RunScreenShot(ctx context.Context, in *Command, opts ...grpc.CallOption) (*Screenshots, error) {
	out := new(Screenshots)
	err := c.cc.Invoke(ctx, "/grpcapi.Admin/RunScreenShot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServer is the server API for Admin service.
type AdminServer interface {
	RunCommand(context.Context, *Command) (*Command, error)
	// rpc RunMinion (Command) returns (Minion);
	AdminDownloadFile(context.Context, *FileMessage) (*File, error)
	AdminSendFile(context.Context, *File) (*FileMessage, error)
	// rpc AdminSendOutput (Command) returns (Command);
	RunAC2Command(context.Context, *C2Command) (*C2Command, error)
	RunOperatorAuthentication(context.Context, *Auth) (*Auth, error)
	TakeAdminScreenShot(context.Context, *C2Command) (*Screenshots, error)
	SendUpload(context.Context, *File) (*FileMessage, error)
	ReceiveDownload(context.Context, *FileMessage) (*File, error)
	RunScreenShot(context.Context, *Command) (*Screenshots, error)
}

// UnimplementedAdminServer can be embedded to have forward compatible implementations.
type UnimplementedAdminServer struct {
}

func (*UnimplementedAdminServer) RunCommand(ctx context.Context, req *Command) (*Command, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommand not implemented")
}
func (*UnimplementedAdminServer) AdminDownloadFile(ctx context.Context, req *FileMessage) (*File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminDownloadFile not implemented")
}
func (*UnimplementedAdminServer) AdminSendFile(ctx context.Context, req *File) (*FileMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminSendFile not implemented")
}
func (*UnimplementedAdminServer) RunAC2Command(ctx context.Context, req *C2Command) (*C2Command, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunAC2Command not implemented")
}
func (*UnimplementedAdminServer) RunOperatorAuthentication(ctx context.Context, req *Auth) (*Auth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunOperatorAuthentication not implemented")
}
func (*UnimplementedAdminServer) TakeAdminScreenShot(ctx context.Context, req *C2Command) (*Screenshots, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeAdminScreenShot not implemented")
}
func (*UnimplementedAdminServer) SendUpload(ctx context.Context, req *File) (*FileMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendUpload not implemented")
}
func (*UnimplementedAdminServer) ReceiveDownload(ctx context.Context, req *FileMessage) (*File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveDownload not implemented")
}
func (*UnimplementedAdminServer) RunScreenShot(ctx context.Context, req *Command) (*Screenshots, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunScreenShot not implemented")
}

func RegisterAdminServer(s *grpc.Server, srv AdminServer) {
	s.RegisterService(&_Admin_serviceDesc, srv)
}

func _Admin_RunCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RunCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/RunCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RunCommand(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_AdminDownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).AdminDownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/AdminDownloadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).AdminDownloadFile(ctx, req.(*FileMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_AdminSendFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(File)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).AdminSendFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/AdminSendFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).AdminSendFile(ctx, req.(*File))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RunAC2Command_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RunAC2Command(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/RunAC2Command",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RunAC2Command(ctx, req.(*C2Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RunOperatorAuthentication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Auth)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RunOperatorAuthentication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/RunOperatorAuthentication",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RunOperatorAuthentication(ctx, req.(*Auth))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_TakeAdminScreenShot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).TakeAdminScreenShot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/TakeAdminScreenShot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).TakeAdminScreenShot(ctx, req.(*C2Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_SendUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(File)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).SendUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/SendUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).SendUpload(ctx, req.(*File))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_ReceiveDownload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).ReceiveDownload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/ReceiveDownload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).ReceiveDownload(ctx, req.(*FileMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Admin_RunScreenShot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServer).RunScreenShot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpcapi.Admin/RunScreenShot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServer).RunScreenShot(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

var _Admin_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpcapi.Admin",
	HandlerType: (*AdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RunCommand",
			Handler:    _Admin_RunCommand_Handler,
		},
		{
			MethodName: "AdminDownloadFile",
			Handler:    _Admin_AdminDownloadFile_Handler,
		},
		{
			MethodName: "AdminSendFile",
			Handler:    _Admin_AdminSendFile_Handler,
		},
		{
			MethodName: "RunAC2Command",
			Handler:    _Admin_RunAC2Command_Handler,
		},
		{
			MethodName: "RunOperatorAuthentication",
			Handler:    _Admin_RunOperatorAuthentication_Handler,
		},
		{
			MethodName: "TakeAdminScreenShot",
			Handler:    _Admin_TakeAdminScreenShot_Handler,
		},
		{
			MethodName: "SendUpload",
			Handler:    _Admin_SendUpload_Handler,
		},
		{
			MethodName: "ReceiveDownload",
			Handler:    _Admin_ReceiveDownload_Handler,
		},
		{
			MethodName: "RunScreenShot",
			Handler:    _Admin_RunScreenShot_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "wheagle.proto",
}
